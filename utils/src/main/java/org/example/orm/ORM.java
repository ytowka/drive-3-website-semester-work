package org.example.orm;


import org.jetbrains.annotations.Nullable;

import java.lang.reflect.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class ORM {

    @SuppressWarnings("unchecked")
    public static <T> T parseResultSet(ResultSet resultSet, Class<T> objectClass) {
        Constructor<?> constructor = objectClass.getConstructors()[0];

        Parameter[] parameters = constructor.getParameters();

        Object[] args = Arrays.stream(parameters).map(parameter -> {
            String name = Arrays
                    .stream(parameter.getAnnotations())
                    .filter(annotation -> annotation instanceof ColumnInfo)
                    .map(annotation -> ((ColumnInfo) annotation).name())
                    .findFirst()
                    .orElseThrow(() -> new RuntimeException("@ColumnInfo is not present on field " + parameter.getName()));
            try {
                Object object = resultSet.getObject(name);
                TypeConverter typeConverter = getTypeConverter(parameter);
                if (typeConverter != null) {
                    object = typeConverter.toObject(object);
                }
                return object;
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }).toArray();


        constructor.setAccessible(true);

        try {
            return (T) constructor.newInstance(args);
        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

    public static <T> Optional<T> parseOptionalResultSet(ResultSet resultSet, Class<T> objectClass) throws SQLException {
        if(resultSet.next()){
            return Optional.of(parseResultSet(resultSet, objectClass));
        }
        return Optional.empty();
    }


    public static <T> List<T> parseResultSetList(ResultSet resultSet, Class<T> objectClass) throws SQLException {
        List<T> list = new ArrayList<>();
        while (resultSet.next()){
            list.add(parseResultSet(resultSet, objectClass));
        }
        return list;
    }

    protected static String appendValues(Field[] columns, Object object) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("(");
        for (int i = 0; i < columns.length; i++) {
            ColumnInfo columnInfo = columns[i].getAnnotation(ColumnInfo.class);
            if (!columnInfo.autoGenerated()) {
                Field column = columns[i];
                column.setAccessible(true);
                stringBuilder.append(convertToDbType(column, columnInfo, object));
                if (i < columns.length - 1) {
                    stringBuilder.append(", ");
                }
            }
        }
        stringBuilder.append(")");
        return stringBuilder.toString();
    }

    protected static String convertToDbType(Field column, ColumnInfo columnInfo, Object object) {
        StringBuilder stringValue = new StringBuilder();
        column.setAccessible(true);
        Object value;
        boolean isString = false;
        try {
            value = column.get(object);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
        TypeConverter typeConverter = getTypeConverter(column);
        if (typeConverter != null) {
            value = typeConverter.toDatabaseType(value);
        }
        System.out.println(value);
        if(value == null){
            return "NULL";
        }
        isString = !value.getClass().isPrimitive();
        if (isString) {
            stringValue.append("'");
        }
        stringValue.append(value);
        if (isString) {
            stringValue.append("'");
        }
        if(!columnInfo.cast().isBlank()){
            stringValue.append("::");
            stringValue.append(columnInfo.cast());
        }

        return stringValue.toString();
    }


    @Nullable
    protected static TypeConverter getTypeConverter(AnnotatedElement annotatedElement) {
        if (annotatedElement.isAnnotationPresent(TypeConverters.class)) {
            Class<? extends TypeConverter<?, ?>> typeConverterClass = annotatedElement.getAnnotation(TypeConverters.class).typeConverterClass();
            try {
                Constructor<? extends TypeConverter<?, ?>> typeConverterConstructor = typeConverterClass.getConstructor();
                typeConverterConstructor.setAccessible(true);
                return typeConverterConstructor.newInstance();
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("Type converter must have constructor without arguments");
            } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        }
        return null;
    }
}
